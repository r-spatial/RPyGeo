% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rpygeo.R
\name{rpygeo.geoprocessor}
\alias{rpygeo.geoprocessor}
\title{ArcGIS Geoprocessor Workhorse}
\usage{
rpygeo.geoprocessor(fun, args = NULL, py.file = "rpygeo.py",
  msg.file = "rpygeo.msg", env = rpygeo.env, extensions = NULL,
  working.directory = getwd(), quote.args = TRUE, add.gp = TRUE,
  wait = TRUE, clean.up = wait, detect.required.extensions = TRUE)
}
\arguments{
\item{fun}{This can be either a complete Python geoprocessing command (see
examples), a single geoprocessing function name, or a vector of function or
Python expressions to be evaluated by the Python geoprocessor.}

\item{args}{Vector or list of arguments to be passed to the function listed
in \code{fun}. The argument \code{quote.args} determines whether these
arguments will be decorated with quotation marks.}

\item{py.file}{Name of the temporary Python script file (in the
\code{working.directory}).}

\item{msg.file}{Name of the temporary file in which to dump Python/ArcGIS
error messages (in the \code{working.directory}).}

\item{env}{A list defining the RPyGeo working environment.  Defaults to the
standard working environment \code{rpygeo.env}, which is created at
start-up.  See \code{\link{rpygeo.build.env}} for details.}

\item{extensions}{Optional character vector listing ArcGIS extension that
should be enabled before using the geoprocessing \code{fun}ction. This adds
to any extensions that are listed in the \code{env}ironment or eventually
detected by \code{rpygeo.required.extensions}.}

\item{working.directory}{The working directory for temporary files (i.e. the
Python script and error message files); defaults to R's current working
directory.}

\item{quote.args}{Logical value (default: \code{TRUE}) or logical vector
that determines whether quotation marks have to be added to the \code{args}
arguments before passing them to Python. If this is a vector, it must have
the same length as \code{args}. See Details.}

\item{add.gp}{Logical (default: \code{TRUE}). See Details.}

\item{wait}{Logical (default: \code{TRUE}). Experimental(!)  option. If
\code{FALSE} (NOT recommended), do not wait for the operating system /
ArcGIS to finish the Python geoprocessing script.}

\item{clean.up}{Logical (default \code{TRUE}) or character vector
(\code{"msg"}, \code{"py"}, or \code{c("msg","py")}).  Determines whether
the error message file, the Python script file, or both (default) should be
deleted after geoprocessing is finished. Ignored if \code{wait} is
\code{FALSE}.}

\item{detect.required.extensions}{Logical (default: \code{TRUE}).
Determines whether \code{rpygeo.required.extensions} should try to find out
which ArcGIS extensions are required to evaluate the \code{fun}ction(s).}
}
\value{
The function returns \code{NULL} if is was successful, or otherwise
a character vector with the ArcGIS error message.  In addition, the ArcGIS
function will generate the output described in the ArcGIS help files etc.
Depending on the \code{clean.up} argument, the Python code may still be
available in the \code{py.file}, and error messages in \code{msg.file}.
}
\description{
This function creates a Python geoprocessing script file and runs it from
the operating system using the ArcGIS Geoprocessor.
}
\details{
This function is the R geoprocessing workhorse that creates a Python
geoprocessing script, runs it, and returns any error messages.

If \code{fun} is a ready-to-use Python expression such as \code{}, then
\code{add.gp} only determines whether the \code{"gp."} has to be added as a
prefix to access the Python geoprocessor or not.

In most cases however, \code{fun} will be a single ArcGIS geoprocessing
script function such as \code{"Slope_sa"}, where \code{"_sa"} tells us that
this function can be found in the Spatial Analyst extension of ArcGIS
(\code{rpygeo.required.extensions} will check this for you if the
\code{detected...} argument is \code{TRUE}) Now \code{args} will be a vector
or list of arguments to \code{Slope_sa}, e.g. \code{c("dem","slope")} or
\code{list("dem","slope","PERCENT_RISE",2)} (see ArcGIS help files for
information on the arguments of \code{Slope_sa}).  These will result in
Python expressions \code{gp.Slope_sa("dem", "slope")} and
\code{gp.Slope_sa("dem", "slope", "PERCENT_RISE", 2)} if \code{add.gp==TRUE}
and if we use the \code{quote.args} arguments \code{TRUE} and
\code{c(T,T,T,F)}, respectively.

Dataset names will always be relative to the path or geodatabase defined in
the geoprocessing environment settings \code{env$workspace}.  Also, ArcGIS
will be allowed to overwrite any existing output files
(\code{env$overwriteoutput==1}) or not (\code{==0}).  See
\code{\link{rpygeo.build.env}} for details.
}
\note{
The Python script created by this geoprocessor is loaded with
initialization code for setting up the ArcGIS workspace and enabling ArcGIS
extensions.  This makes this function pretty inefficient, but you save a lot
of time because you don't have to switch between three applications and two
programming languages...

ArcGIS is pretty flexible with respect to numeric arguments such as the z
factor in \code{Slope_sa} being passed as character string.  As a
consequence, \code{quote.args=TRUE} will normally work fine.

\code{wait==FALSE} is experimental and not recommended. Watch for file name
conflicts if you really want to try it - competing geoprocessing scripts
must use different temporary Python script files etc.
}
\examples{

# Allow ArcGIS to overwrite existing datasets:
\dontrun{rpygeo.env$overwriteoutput = 1}
# Calculate the slope of a DEM raster dataset
# in the current ArcGIS workspace:
\dontrun{rpygeo.geoprocessor("Slope_sa",c("dem","slope"))}
# Same:
\dontrun{rpygeo.geoprocessor("Slope_sa('dem','slope')")}
# Same, using the more convenient wrapper:
\dontrun{rpygeo.Slope.sa("dem","slope")}

# Three at a time or separately:
\dontrun{date()}
\dontrun{rpygeo.geoprocessor("Slope_sa('dem','slope')",
  "Aspect_sa('dem','aspect')", "Hillshade_sa('dem','hshd')")}
\dontrun{date()} # ~20 sec on my computer
\dontrun{rpygeo.Slope.sa("dem","slope")}
\dontrun{rpygeo.Aspect.sa("dem","aspect")}
\dontrun{rpygeo.Hillshade.sa("dem","hshd")}
\dontrun{date()} # ~50 sec
\dontrun{rpygeo.Delete.management("slope")}
\dontrun{rpygeo.Delete.management("aspect")}
\dontrun{rpygeo.Delete.management("hshd")}

# Calculate the Euclidian distance from railway lines
# up to a max. distance of 1000 map units:
\dontrun{rpygeo.geoprocessor("EucDistance_sa",
    args=list("rail.shp","raildist",1000))}
# Same:
\dontrun{rpygeo.EucDistance.sa("rail.shp","raildist",maxdist=1000)}

# Use MapAlgebra to calculate a distance-decay function:
\dontrun{rpygeo.geoprocessor("SingleOutputMapAlgebra_sa",
    args=c("exp( raildist / -100 )","distdecay"))}

# Or why not in just one step if you like MapAlgebra:
\dontrun{rpygeo.geoprocessor( "SingleOutputMapAlgebra_sa",
    args=c("exp( EucDistance( rail.shp, \\#, \\#, 1000 ) / -100 )","distdecay") )}

}
\seealso{
\code{\link{rpygeo.build.env}}
}
\author{
Alexander Brenning
}
\keyword{database}
\keyword{interface}
